/*
 * st7565.c
 *
 *  Created on: Jul 10, 2015
 *      Author: Jun
 */


/*
 * st7565.c
 *
 *  Created on: Jun 30, 2015
 *      Author: Jun
 */
#include "st7565.h"
#include "glcd_font.h"


extern uint8_t m_page;

int random_back_light = 0;
const uint8_t pagemap[] = { 3, 2, 1, 0, 7, 6, 5, 4 };

// a 5x7 font table

#define ST7565_STARTBYTES 1


// the memory buffer for the LCD
uint8_t st7565_buffer[1024] = {
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x10,
		0xA0,0x00,0xA8,0x00,0x28,0xC0,0xE8,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xE0,0xE0,
		0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x24,0xC8,0x12,0x24,
		0x49,0x2A,0x50,0xA5,0x8F,0x3F,0x5F,0xBF,0x3D,0x3B,0x7E,0x3D,0x7F,0x7F,0x7F,0x7B,
		0x7D,0x7F,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,
		0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,
		0xC0,0xA1,0xA0,0xF0,0xD8,0xF0,0xF8,0x50,0xE0,0x80,0x02,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x04,0x01,0x01,
		0x0A,0x01,0x02,0x0C,0x11,0x85,0x02,0x0D,0x92,0x05,0x54,0x85,0x22,0x44,0x0A,0x61,
		0x04,0x20,0x91,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xF8,0xE4,0xDE,0x6B,0xFD,0xFF,0xDA,
		0xF5,0xEE,0x3E,0x3F,0x13,0x1F,0x0B,0x01,0x01,0x00,0x20,0x00,0x10,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x14,0x40,0x0A,0x50,
		0x04,0x5A,0xC0,0x14,0xA2,0x0C,0xA1,0x2E,0x40,0x9D,0xA2,0x09,0x40,0x12,0x04,0x40,
		0x08,0xA0,0x00,0x00,0x22,0x84,0x10,0x00,0x00,0x20,0x00,0x00,0x80,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,
		0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x08,0x00,
		0x00,0x00,0x00,0x50,0xF0,0xD0,0xD8,0xB0,0xE0,0xB8,0xD0,0x78,0xE8,0xBC,0x5E,0xDF,
		0xAB,0x5A,0xD0,0x58,0xD0,0x20,0x40,0xF0,0x20,0xE0,0x60,0x00,0x00,0x10,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x10,0x22,0x04,0x01,0x00,0x05,0x08,
		0xA2,0x08,0x22,0x49,0x90,0x26,0x48,0x93,0x28,0x42,0xA9,0x15,0xAA,0x05,0x48,0x95,
		0x04,0x02,0x20,0x00,0x80,0x00,0x01,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
		0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x12,0xFD,0x73,0xBD,0xF7,0xD5,0x3F,0xDA,0xF7,0x1F,0xF7,0x5F,0xF3,0x5E,
		0xF3,0xAF,0x1D,0xEB,0xC9,0x1B,0xCA,0x12,0xA6,0x04,0xDD,0x20,0x80,0x10,0xA0,0x40,
		0xC0,0xC0,0xA0,0xC0,0xE0,0x30,0xC0,0x52,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x02,0x00,0x12,0x44,0x01,0x24,0x4C,0x01,0x5A,0x00,0x56,0x00,0x4A,0x90,0x00,
		0x24,0x00,0x00,0x40,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,
		0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xF8,0xFD,0xBF,
		0xF7,0x7F,0xED,0xFF,0x5B,0xFE,0xEB,0xBF,0x7B,0xFF,0x5B,0xFE,0xFF,0xDF,0x3D,0xFF,
		0xF5,0x7F,0xFA,0xFE,0xB1,0x7E,0xF4,0xFF,0xDC,0xFD,0xFB,0xAF,0x7C,0xF8,0xE0,0x00,
		0x00,0x00,0x00,0x03,0x01,0x03,0x01,0x00,0x00,0x00,0x00,0x04,0x00,0x80,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x04,0x01,0x09,0x02,0x00,0x0A,0x40,0x01,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x02,0x13,0x2F,0x1E,0x3B,
		0x6F,0x3F,0x6B,0x7F,0xDF,0x7E,0xEB,0x7F,0xF5,0x6F,0x7D,0x77,0x5E,0x14,0x1F,0x12,
		0x0F,0x1B,0x07,0x0F,0x07,0x0F,0x07,0x07,0x06,0x07,0x07,0x07,0x07,0x03,0x03,0x00,
		0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x08,0x00,0x20,0x20,0x00,0x10,0x20,0x40,0x10,0x40,0x10,0x40,0x10,0x20,0x00,
		0x10,0x00,0x20,0x01,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
		};


#define enablePartialUpdate

#ifdef enablePartialUpdate
static uint8_t xUpdateMin, xUpdateMax, yUpdateMin, yUpdateMax;
#endif



static void updateBoundingBox(uint8_t xmin, uint8_t ymin, uint8_t xmax, uint8_t ymax) {
#ifdef enablePartialUpdate
  if (xmin < xUpdateMin) xUpdateMin = xmin; 
  if (xmax > xUpdateMax) xUpdateMax = xmax;
  if (ymin < yUpdateMin) yUpdateMin = ymin;
  if (ymax > yUpdateMax) yUpdateMax = ymax;
#endif
}



void glcd_begin(uint8_t contrast) {
  st7565_init();
  st7565_command(CMD_DISPLAY_ON);
  st7565_command(CMD_SET_ALLPTS_NORMAL);
  st7565_set_brightness(contrast);
  backLightControl(true, false, false);
  
}

inline void spiwrite(uint8_t c){
	int8_t i;
	for (i=7; i>=0; i--) {
		SIU.GPDO[PIN_GLCD_SCLK].B.PDO &= 0;
	    if (c & _BV(i))
	    	SIU.GPDO[PIN_GLCD_SID].B.PDO |= 1;
	    else
	    	SIU.GPDO[PIN_GLCD_SID].B.PDO &= 0;
		SIU.GPDO[PIN_GLCD_SCLK].B.PDO |= 1;	
	}
	  
}

void st7565_init(void){
	SIU.PCR[PIN_GLCD_CS].R = OUTPUT; 
    SIU.PCR[PIN_GLCD_RST].R = OUTPUT;
    SIU.PCR[PIN_GLCD_AO].R = OUTPUT;
    SIU.PCR[PIN_GLCD_SID].R = OUTPUT;
    SIU.PCR[PIN_GLCD_SCLK].R = OUTPUT;
    SIU.PCR[PIN_GLCD_LEDBLUE].R = OUTPUT;
    SIU.PCR[PIN_GLCD_LEDGREEN].R = OUTPUT;
    SIU.PCR[PIN_GLCD_LEDRED].R = OUTPUT;
        
                
    	
    if(PIN_GLCD_CS > 0)
    	GPIO_SetState(PIN_GLCD_CS, LOW);
    
    GPIO_SetState(PIN_GLCD_RST, LOW);
    sdelay(1);
    GPIO_SetState(PIN_GLCD_RST, HIGH);
    
	// LCD bias select
	st7565_command(CMD_SET_BIAS_7);
	// ADC select
	st7565_command(CMD_SET_ADC_NORMAL);
	// SHL select
	st7565_command(CMD_SET_COM_NORMAL);
	// Initial display line
	st7565_command(CMD_SET_DISP_START_LINE);
	
	// turn on voltage converter (VC=1, VR=0, VF=0)
	st7565_command(CMD_SET_POWER_CONTROL | 0x4);
	// wait for 50% rising
	mdelay(200);
	
	// turn on voltage regulator (VC=1, VR=1, VF=0)
	st7565_command(CMD_SET_POWER_CONTROL | 0x6);
	// wait >=50ms
	mdelay(200);
	
	// turn on voltage follower (VC=1, VR=1, VF=1)
	st7565_command(CMD_SET_POWER_CONTROL | 0x7);
	// wait
	mdelay(40);
	
	// set lcd operating voltage (regulator resistor, ref voltage resistor)
	st7565_command(CMD_SET_RESISTOR_RATIO | 0x6);
	
	// initial display line
	// set page address
	// set column address
	// write display data

	updateBoundingBox(0, 0, LCDWIDTH-1, LCDHEIGHT-1);
}


void st7565_command(uint8_t c){
	SIU.GPDO[PIN_GLCD_AO].B.PDO &=0;
	spiwrite(c);
}
void st7565_data(uint8_t c){
	SIU.GPDO[PIN_GLCD_AO].B.PDO |=1;
	spiwrite(c);
}

void st7565_set_brightness(uint8_t val) {
    st7565_command(CMD_SET_VOLUME_FIRST);
    st7565_command(CMD_SET_VOLUME_SECOND | (val & 0x3f));
}


void glcd_clear_screen(void) {
 /* uint8_t p, c;
  
  for(p = 0; p < 8; p++) {
    

    st7565_command(CMD_SET_PAGE | p);
    for(c = 0; c < 129; c++) {
      //uart_putw_dec(c);
      //uart_putchar(' ');
      st7565_command(CMD_SET_COLUMN_LOWER | (c & 0xf));
      st7565_command(CMD_SET_COLUMN_UPPER | ((c >> 4) & 0xf));
      st7565_data(0x0);
    }     
  }*/
	
	int i, j;
	for ( i=0; i < LCDWIDTH; i++){
		for ( j=0; j < LCDHEIGHT; j++){
			setpixel(i, j, WHITE);
		}
	}
}

void glcd_small_clear(){
	int i, j;
	for (i = 0; i < 60; i++){
		for( j = 0; j < 32; j++){
			setpixel(i,j,WHITE);
		}
	}
}


void write_buffer(uint8_t *buffer);


void glcd_display(void) {
	uint8_t col, maxcol, p;

	for(p = 0; p < 8; p++) {
			
		#ifdef enablePartialUpdate
			// check if this page is part of update
			if ( yUpdateMin >= ((p+1)*8) ) {
			  continue;   // nope, skip it!
			}
			if (yUpdateMax < p*8) {
			  break;
			}
		#endif
		
		st7565_command(CMD_SET_PAGE | pagemap[p]);
		
		
		#ifdef enablePartialUpdate
			col = xUpdateMin;
			maxcol = xUpdateMax;
			#else
				// start at the beginning of the row
				col = 0;
			maxcol = LCDWIDTH-1;
		#endif
		
		st7565_command(CMD_SET_COLUMN_LOWER | ((col+ST7565_STARTBYTES) & 0xf));
		st7565_command(CMD_SET_COLUMN_UPPER | (((col+ST7565_STARTBYTES) >> 4) & 0x0F));
		st7565_command(CMD_RMW);
		
		for(; col <= maxcol; col++) {
		  //uart_putw_dec(col);
		  //uart_putchar(' ');
		  st7565_data(st7565_buffer[(128*p)+col]);
		}
	}

	#ifdef enablePartialUpdate
	  xUpdateMin = LCDWIDTH - 1;
	  xUpdateMax = 0;
	  yUpdateMin = LCDHEIGHT-1;
	  yUpdateMax = 0;
	#endif
}



//void updateBoundingBox(uint8_t xmin, uint8_t ymin, uint8_t xmax, uint8_t ymax) {
//	
//	#ifdef enablePartialUpdate
//		if (xmin < xUpdateMin) xUpdateMin = xmin;
//		if (xmax > xUpdateMax) xUpdateMax = xmax;
//		if (ymin < yUpdateMin) yUpdateMin = ymin;
//		if (ymax > yUpdateMax) yUpdateMax = ymax;
//	#endif
//		
//}

void setpixel(uint8_t x, uint8_t y, uint8_t color) {
  if ((x >= LCDWIDTH) || (y >= LCDHEIGHT))
    return;

  // x is which column
  if (color) 
    st7565_buffer[x+ (y/8)*128] |= _BV(7-(y%8));  
  else
    st7565_buffer[x+ (y/8)*128] &= ~_BV(7-(y%8)); 

  updateBoundingBox(x,y,x,y);
}

#define NUMFLAKES 10
#define XPOS 0
#define YPOS 1
#define DELTAY 2

void testdrawbitmap(const uint8_t *bitmap, uint8_t w, uint8_t h);

void backLightControl(bool blue, bool green, bool red){
	GPIO_SetState(PIN_GLCD_LEDBLUE, ~blue);
	GPIO_SetState(PIN_GLCD_LEDGREEN, ~green);
	GPIO_SetState(PIN_GLCD_LEDRED, ~red);
		
}
void drawchar(uint8_t x, uint8_t line, char c){
	for (uint8_t i =0; i<5; i++ ) {
		st7565_buffer[x + (line*128) ] = font[(c*5)+i];
		x++;
	}
	
	updateBoundingBox(x, line*8, x+5, line*8 + 8);
}

void drawstring(uint8_t x, uint8_t line, char *c) {
  while (c[0] != 0) {
    drawchar(x, line, c[0]);
    c++;
    x += 6; // 6 pixels wide
    if (x + 6 >= LCDWIDTH) {
      x = 0;    // ran out of this line
      line++;
    }
    if (line >= (LCDHEIGHT/8))
      return;        // ran out of space :(
  }
}

void testdrawchar(void) {
  for (uint8_t i=0; i < 168; i++) {
    drawchar((i % 21) * 6, i/21, i);
  }    
}
// bresenham's algorithm - thx wikpedia



void drawline(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, 
		      uint8_t color) {
  uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    swap(x0, x1);
    swap(y0, y1);
  }

  // much faster to put the test here, since we've already sorted the points
  updateBoundingBox(x0, y0, x1, y1);

  uint8_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int8_t err = dx / 2;
  int8_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;}

  for (; x0<=x1; x0++) {
    if (steep) {
      my_setpixel(y0, x0, color);
    } else {
      my_setpixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}



void my_setpixel(uint8_t x, uint8_t y, uint8_t color) {
  if ((x >= LCDWIDTH) || (y >= LCDHEIGHT))
    return;

  // x is which column
  if (color) 
    st7565_buffer[x+ (y/8)*128] |= _BV(7-(y%8));  
  else
    st7565_buffer[x+ (y/8)*128] &= ~_BV(7-(y%8)); 
}

void draw_string_under_line(uint8_t line){
	if ( line > 8)
		return ;
	line = (line * 8) + 7; 
	
	drawline(0, line, LCDWIDTH, line, BLACK);
}
void glcd_random_back_light(int delay){
	
	
	int blue, green, red;
	blue = random_back_light / (2*delay);
	green = random_back_light / (3*delay);
	red = random_back_light / (5*delay);
	
	backLightControl(blue % 2, green % 2, red % 2);

	random_back_light++;
	if ( random_back_light > 100 ) 
		random_back_light = 0;
	
		
}
